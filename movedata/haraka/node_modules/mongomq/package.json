{
  "author": {
    "name": "Jeremy Darling",
    "email": "jeremy.darling@gmail.com"
  },
  "name": "mongomq",
  "version": "0.3.4",
  "repository": {
    "type": "git",
    "url": "git://github.com/jdarling/MongoMQ.git"
  },
  "main": "./lib/lib",
  "contributors": [
    {
      "name": "mfrobben"
    },
    {
      "name": "joscha"
    }
  ],
  "engines": {
    "node": ">= v0.8.2"
  },
  "dependencies": {
    "mongodb": "1.3.x",
    "node-uuid": "1.4.0"
  },
  "readme": "MongoMQ v0.3.x\r\n==============\r\n\r\nVersion 0.3.x introduces new functionality and many bug fixes over v0.2.x.  It also introduces some minor changes to packet format and thus is not backwards compatable with v0.2.x\r\n\r\nBiggest differences from 0.2.x to 0.3.x\r\n=======================================\r\n\r\n  * Partial callbacks were removed.  They didn't serve any purpose.\r\n  * Large messages are pushed to GridFS (planned feature)\r\n  * Message format changed, backward compatible for the most part, must turn on the options.support_v2 flag\r\n  * OnAny has been temporarily removed, *BREAKING CHANGE*\r\n  * Logging support (started, but not complete/tested)\r\n\r\nInstallation\r\n============\r\n\r\nFrom GitHub\r\n-----------\r\n  * Download from GitHub and extract.\r\n  * change to extracted directory\r\n  * execute \"npm install\"\r\n\r\nUsing NPM\r\n---------\r\n  * npm install mongomq\r\n\r\nRequirements\r\n============\r\n  * Node.js - v0.8.2 or better (really only for the MongoMQ and Test.js scripts REPL support)\r\n  * MongoDB - v2.1.2 or better (for Tailable Cursors, autoIndexId bug fix, and ReplicaSet fixes)\r\n\r\nWhat is MongoMQ?\r\n================\r\n\r\nMongoMQ is a messaging queue built on top of Node.js and MongoDB's tailable cursors.  It allows for distributed of messages across workers in both a single reciever and broadcast method.\r\n\r\nWhat MongoMQ is NOT\r\n===================\r\n\r\nMongoMQ does NOT (currently) support callback's once a message is processed.  Instead it is recommended that you use a one time listener to pickup responses if this is required.\r\n\r\nSupported Methods\r\n=================\r\n\r\nnew MongoMQ(options)\r\n--------------------\r\n\r\nMongoMQ.start([callback])\r\n-------------------------\r\n\r\nStarts the queue listener and sets up the emitter.\r\n\r\nParams:\r\n* callback - will be called once the queue is opened and all registered listeners are setup\r\n\r\nMongoMQ.stop([callback])\r\n------------------------\r\n\r\nStops listening for messages and closes the emitter.\r\n\r\nParams:\r\n* callback - will be called once the queue is completely close and all registered listeners have been shut down\r\n\r\nMongoMQ.emit(msgType, data, [completeCallback])\r\n------------------------------------------------------------------\r\n\r\nPlaces the a message of msgTye on the queue with the provided data for handlers to consume.\r\n\r\nParams:\r\n\r\n  * msgType - The message type to emit.\r\n  * data - a JSON serializeable collection of data to be sent.\r\n  * completeCallback - Will be called once all remote processing has been completed.\r\n\r\nMongoMQ.on(msgType, [options], handler)\r\n---------------------------------------\r\n\r\nSets up a listener for a specific message type.\r\n\r\nParams:\r\n\r\n* msgType - The message type to listen for can be a string or a regular expression\r\n* options - additional options that can be passed\r\n* handler(err, messageContents, next) - Use next() to look for another message in the queue, don't call next() if you only want a one time listener\r\n    * If you want to send back data or partial data use next(data, complete) where complete should be true if you have sent all of your responses, see test.js r.context.tmp for a simple example.\r\n\r\noptions -\r\n\r\nMongoMQ.listeners(event)\r\n------------------------------------------\r\n\r\nProvides back an array of listeners that matche the supplied event.  Returns an empty array if no listeners are subscribed to the event.\r\n\r\nParams:\r\n* event - The name of the event to look for.\r\n\r\nMongoMQ.removeListener(event, handler)\r\n------------------------------------------\r\n\r\nShuts down the first listener that matches the supplied event and handler and removes it from the listeners list.\r\n\r\nParams:\r\n* event - The name of the event to look for.\r\n* handler - The specific handler function to look for.\r\n\r\nMongoMQ.removeAllListeners(event)\r\n------------------------------\r\n\r\nShuts down ALL listeners for the specified event and removes them from the listeners list.\r\n\r\nParams:\r\n* event - The name of the event to look for.\r\n\r\nHow does MongoMQ work?\r\n======================\r\n\r\nMongoMQ sets up a tailable collection and then starts listeners using find in conjunction with findAndModify to pickup messages out of this collection.\r\n\r\nSince MongoMQ is basically a wrapper around MongoDB's built in support for tailable cursors it is possible to place listeners built in other langauges on the \"queue\".\r\n\r\nSample Usage\r\n============\r\n\r\n  * Ensure MongoDB is up and running locally (or modify the config options to collect to your Mongo instance)\r\n  * Start 3 copies of the bin/test.js script.\r\n  * In two copies type listen() to setup a \"test\" message listener\r\n  * In the 3rd copy type load() to send 100 test messages to the queue\r\n  \r\nYou should see the two listeners pickup messages one at a time with whoever has resources to process picking up the message first.\r\n\r\nbin/test.js\r\n===========\r\n\r\n```javascript\r\nvar MongoMQ = require('../lib/MongoMQ').MongoMQ;\r\nvar repl = require('repl');\r\n\r\nvar queue = new MongoMQ({\r\n  autoStart: true\r\n});\r\n\r\nvar r = repl.start({\r\n      prompt: \"testbed>\"\r\n    });\r\nr.on('exit', function(){\r\n  queue.stop();\r\n});\r\n\r\nvar msgidx = 0;\r\nr.context.send = function(){\r\n  queue.emit('test', msgidx);\r\n  msgidx++;\r\n};\r\n\r\nr.context.load = function(){\r\n  for(var i = 0; i<100; i++){\r\n    queue.emit('test', msgidx);\r\n    msgidx++;\r\n  }\r\n};\r\n\r\nvar logMsg = function(err, data, next){\r\n      console.log('LOG: ', data);\r\n      next();\r\n    };\r\nvar eatTest = function(err, data, next){\r\n      console.log('eat: ', data);\r\n      next();\r\n    };\r\n\r\nr.context.logAny = function(){\r\n  queue.onAny(logMsg);\r\n};\r\n\r\nr.context.listen = function(){\r\n  queue.on('test', eatTest);\r\n};\r\n\r\nr.context.start = function(cb){\r\n  queue.start(cb);\r\n};\r\n\r\nr.context.stop = function(){\r\n  queue.stop();\r\n};\r\n\r\nr.context.help = function(){\r\n  console.log('Built in test methods:\\r\\n'+\r\n      '  help()    - shows this message\\r\\n'+\r\n      '  logAny()  - logs any message to the console\\r\\n'+\r\n      '  eatTest() - consumes next available \"test\" message from the queue\\r\\n'+\r\n      '  send()    - places a \"test\" message on the queue\\r\\n'+\r\n      '  load()    - places 100 \"test\" messages on the queue\\r\\n'+\r\n      '  start()   - start the queue listener\\r\\n'+\r\n      '  stop()    - stop the queue listener\\r\\n'+\r\n      '\\r\\nInstance Data\\r\\n'+\r\n      '  queue - the global MongoMQ instance\\r\\n'\r\n      );\r\n  return '';\r\n};\r\n\r\n/*\r\nqueue.start(function(){\r\n  r.context.eatTest();\r\n});\r\n*/\r\n\r\nr.context.queue = queue;\r\n\r\nr.context.help();\r\n```\r\n\r\nHow Events are stored\r\n=====================\r\n\r\n```javascript\r\n{\r\n  _id: ObjectId(), // for internal use only\r\n  pkt_ver: 3, // Packet version that this message is being sent in\r\n  event: event, // string that represents what type of event this is\r\n  data: message, // Contains the actual message contents\r\n  handled: false, // states if the message has been handled or not\r\n  localTime: dt, // Local Date Time of when the message was put on the queue\r\n  globalTime: new Date(dt-self.serverTimeOffset), // Date Time offset to server time of when the message was put on the queue\r\n  pickedTime: new Date(dt-self.serverTimeOffset), // Date Time offset to server time of when the message was picked up from the queue\r\n  host: string, // Contains the host name of the machine that initiated the event\r\n  [response_id: string] // optional if the event expects response(s) this will be the conversation identifier used to track those responses\r\n}\r\n```\r\n\r\nUpdate History\r\n==============\r\n\r\nv0.3 Update History\r\n-------------------\r\n\r\nv0.3.4\r\n  * Fix QueueMonitor.js call from options to self.options in handleResponse\r\n\r\nv0.3.3\r\n  * Fixed package.json and upreved version to pickup changes.\r\n\r\nv0.3.2\r\n  * Upgraded to latest (1.3.6) version of Mongo Node Native\r\n  * Fixed typo in lib.js for inclusion of Logging (changed Logging to logging)\r\n  * Locked dependency versions so breaking shouldn't happen again when the dependency chain changes\r\n\r\nv0.3.1\r\n  * Added setTimeout to nextTick on startup to give Mongo a chance to get connceted to\r\n  * Minor bug fix due to EventEmitter treating 'error' events specially\r\n  * Tweak to once listeners to call next if it exists.  Shouldn't change anything but it is good practice.\r\n\r\nv0.3.0\r\n  * Initial release of v0.3.x, includes many new features and functionality along with many bug fixes.\r\n\r\nv0.2 Update History\r\n-------------------\r\n\r\nv0.2.10&v0.2.11\r\n  * Workaround for Mongo Native Driver not supporting tailed cursor auto-reconnects when Mongo server goes away.\r\n\r\nv0.2.9\r\n  * Change SafeDBDriver default value from false to true, this fixes the issue with multiple listeners picking up the same message since Mongo doesn't perform record locking on updates if this isn't true.\r\n  * Fix autoStart\r\n  * Resolves #9 and #10\r\n  \r\nv0.2.8\r\n  * Upgraded code for new MongoDB Native Drivers (thanks mfrobben for starting points)\r\n  * Readme cleanup (thanks ttezel for pointing this out and fixing it)\r\n  * Resolves #7 and #6\r\n\r\nv0.2.7\r\n  * Fixed a cursor leak when using passive callbacks\r\n\r\nv0.2.6\r\n  * Bug fix related to relplica set configuration loading from config.json files\r\n\r\nv0.2.5\r\n  * General code cleanup and optimizations\r\n  * Examples cleanup and fixes\r\n\r\nv0.2.4\r\n  * Examples added\r\n\r\nv0.2.3\r\n  * Minor bug fix related to passive listeners where a fromDT was not passed in the options\r\n  * Added hostName to messages for better tracking/logging\r\n  * Modified passive callback to pass the actual message as the \"this\" argument, you can now use this.event to get the actual event that was responded to\r\n  * Updated the on() method to accept strings or regular expressions to filter events on\r\n\r\nv0.2.2\r\n  * Completed code to allow for callbacks and partial callbacks to be issued back to emit statements\r\n  * Complteed refactoring of code to properly seperate functionality into objects\r\n\r\nv0.2.1\r\n  * Majorly refactored code\r\n  * Added autoIndexId: true to queue collection creation\r\n  * Better MongoMQ application with help()\r\n  * Updated test application\r\n  * Added an exception to emit() when you try to emit before start() has been called\r\n  * fix to onAny so it will restart listeners after a close() and start() re-issue\r\n  * Added remove*() methods\r\n  * Changed close() to stop()\r\n  * hereOnOut options - allows listeners to only pay attention to messages posted after they have been started up\r\n  * Added ability to register listeners (via on and onAny) when queue is not started\r\n\r\nv0.1.1\r\n  * Bug fixes to on event\r\n  * Added in new onAny register\r\n  * Migrated code to retain cursor\r\n  \r\nv0.1.0\r\n  * Initial release\r\n  * More of a proof of concept",
  "readmeFilename": "readme.md",
  "description": "MongoMQ v0.3.x\r ==============",
  "bugs": {
    "url": "https://github.com/jdarling/MongoMQ/issues"
  },
  "_id": "mongomq@0.3.4",
  "dist": {
    "shasum": "a18d61a65fd10cc90dd5c61421e65d6a208894c8"
  },
  "_from": "mongomq@",
  "_resolved": "https://registry.npmjs.org/mongomq/-/mongomq-0.3.4.tgz"
}
